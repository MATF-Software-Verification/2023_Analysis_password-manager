--------------------------------------------------------------------------------
Profile data file 'callgrind_output/callgrind_generate_and_copy_password.out' (creator: callgrind-3.15.0)
--------------------------------------------------------------------------------
I1 cache: 32768 B, 64 B, 8-way associative
D1 cache: 32768 B, 64 B, 8-way associative
LL cache: 3145728 B, 64 B, 12-way associative
Timerange: Basic block 0 - 68957
Trigger: Program termination
Profiled target:  ../../../password-manager-master/pm -kf ../../password-manager-master/key.txt -gp -c verifikacija (PID 10205, part 1)
Events recorded:  Ir Dr Dw I1mr D1mr D1mw ILmr DLmr DLmw Bc Bcm Bi Bim
Events shown:     Ir Dr Dw I1mr D1mr D1mw ILmr DLmr DLmw Bc Bcm Bi Bim
Event sort order: Ir Dr Dw I1mr D1mr D1mw ILmr DLmr DLmw Bc Bcm Bi Bim
Thresholds:       99 0 0 0 0 0 0 0 0 0 0 0 0
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir      Dr     Dw     I1mr  D1mr  D1mw ILmr  DLmr  DLmw Bc     Bcm   Bi  Bim 
--------------------------------------------------------------------------------
338,510 76,945 26,541 1,387 3,154  805 1,352 2,351  723 59,964 6,211 644 245  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir     Dr     Dw    I1mr D1mr  D1mw ILmr DLmr DLmw Bc     Bcm   Bi  Bim  file:function
--------------------------------------------------------------------------------
71,545 14,316    15   10 1,086    1   10  842    0 15,770 2,025   2   2  /build/glibc-LcI20x/glibc-2.31/elf/dl-addr.c:_dl_addr [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
42,108 14,110 6,247   15   294   15   15  193    5  6,134   377   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-lookup.c:do_lookup_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
30,366  5,418 4,530   26     0    0   26    0    0     96    34   .   .  /home/emilija/Desktop/password-manager-master/source/console/pm_aes.c:Cipher [/home/emilija/Desktop/password-manager-master/pm]
30,237  5,996 3,301   10   113   12   10  100    1  3,618   219   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-lookup.c:_dl_lookup_symbol_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
25,637  4,989    80    5    34    2    5   34    2  7,965   921   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-tunables.c:__GI___tunables_init [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
22,638  5,389 2,656   28   460  283   28  432  271  4,945    78 210  55  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
13,596  3,110 1,306    5     2    4    5    0    2  1,928    52   .   .  /build/glibc-LcI20x/glibc-2.31/stdlib/random_r.c:srandom_r [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
12,344  2,114   263   12     4    0   12    2    0  3,818   134   .   .  /home/emilija/Desktop/password-manager-master/source/console/pm_b64.c:b64_decode [/home/emilija/Desktop/password-manager-master/pm]
11,571  2,386     0   46   102    0   46   71    0  1,338   220  87  58  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/strcmp.S:strcmp [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
11,404  2,825   362   10   311    2   10  289    0  2,041   110   .   .  /build/glibc-LcI20x/glibc-2.31/elf/do-rel.h:_dl_relocate_object
 8,223  1,522     0    1     9    0    1    9    0  2,246    85   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-tunables.h:__GI___tunables_init
 8,063  2,684   928    6   141    4    6   97    1  1,061    43   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-lookup.c:check_match [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
 4,094  1,384   405   18    41   29   18   37   28    752   117   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-version.c:_dl_check_map_versions [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
 2,054    550   422    4     5    0    4    5    0    300    39   .   .  /home/emilija/Desktop/password-manager-master/source/console/pm_aes.c:KeyExpansion [/home/emilija/Desktop/password-manager-master/pm]
 1,949    443   209   35     6   17   34    6   17    308    86  26  14  /build/glibc-LcI20x/glibc-2.31/elf/dl-load.c:_dl_map_object_from_fd [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
 1,399    259   150   28     3    6   28    2    6    340    59   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-deps.c:_dl_map_object_deps [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
 1,398    213     0    4    18    0    4   18    0    389    36   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-cache.c:_dl_cache_libcmp [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
 1,132    281   164    2     0    0    2    0    0    164    43   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-misc.c:_dl_name_match_p [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
 1,031    260   127   68    32   17   68   19   14    214    81  11   7  /build/glibc-LcI20x/glibc-2.31/elf/rtld.c:dl_main [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
 1,006    262   152    6     0    0    6    0    0    232     3   .   .  /build/glibc-LcI20x/glibc-2.31/libio/fileops.c:_IO_file_overflow@@GLIBC_2.2.5 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   992    145   105   10     0    0   10    0    0     92     8   .   .  /home/emilija/Desktop/password-manager-master/source/console/pm_b64.c:b64_encode [/home/emilija/Desktop/password-manager-master/pm]
   964    132   102    9    23   20    9   23   20    243    32   .   .  /build/glibc-LcI20x/glibc-2.31/elf/get-dynamic-info.h:_dl_map_object_from_fd
   956    240    90    3     0    0    3    0    0    149    11   .   .  /build/glibc-LcI20x/glibc-2.31/stdlib/random_r.c:random_r [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   908    194   137   22     1    8   22    1    8    161    40   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-load.c:_dl_map_object [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   902    216   107   18    11    2   18   11    2    128    37   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-load.c:open_verify.constprop.0 [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   881    341    18   23     4    0   23    4    0    291    94   .   .  /home/emilija/Desktop/password-manager-master/source/console/pm_parse.c:parse_flags [/home/emilija/Desktop/password-manager-master/pm]
   870     16   390    9     0   91    4    0   91    131    42   .   .  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:memset [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   835    141   142   21     1    4   21    0    4    114    38   .   .  /build/glibc-LcI20x/glibc-2.31/malloc/malloc.c:_int_malloc [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   829    101   107    3     0    0    3    0    0    170    19   .   .  /home/emilija/Desktop/password-manager-master/source/console/pm_aes.c:AES_CTR_xcrypt_buffer [/home/emilija/Desktop/password-manager-master/pm]
   813    148   157   15     4   30   15    4   30    128    52   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-object.c:_dl_new_object [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   768      0   130    1     0   35    1    0   34    127    10   .   .  /build/glibc-LcI20x/glibc-2.31/malloc/malloc.c:ptmalloc_init.part.0
   762    213   108   17     0    5   17    0    5    103    27   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-load.c:open_path [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   758    111    24   10     6    0   10    6    0    271    44   .   .  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86/cacheinfo.c:intel_check_word.isra.0 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   720    140   140    5     0    0    5    0    0     85     5   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-minimal.c:malloc [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   634    200   123   12    31    0   12    0    0     92    31   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-reloc.c:_dl_relocate_object [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   630    210    90    2     0    0    2    0    0     90     .   .   .  /build/glibc-LcI20x/glibc-2.31/stdlib/random.c:random [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   606    162    56   20     4    0   10    0    0    114    55   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-sort-maps.c:_dl_sort_maps [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   598     80    82   26     0    8   26    0    8     84    45   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-hwcaps.c:_dl_important_hwcaps [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   572    222    49   16     2    0   16    0    0    142    16   .   .  /home/emilija/Desktop/password-manager-master/source/console/pm_xcrypt.c:encrypt_and_replace [/home/emilija/Desktop/password-manager-master/pm]
   550    151    43   17    23    5   16   21    5    129    29  18  14  /build/glibc-LcI20x/glibc-2.31/elf/../elf/dl-sysdep.c:_dl_sysdep_start [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   546     87     0    6     2    0    6    2    0     48    14   .   .  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/multiarch/../strlen.S:strlen [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   542    117    59   16    15    1   16   15    1     98    27   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-cache.c:_dl_load_cache_lookup [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   525    108    27    6    25    0    3    0    0     78    38   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-tunables.c:__tunable_get_val [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   510      0     0    1     0    0    1    0    0     81    11   .   .  /build/glibc-LcI20x/glibc-2.31/string/../bits/stdlib-bsearch.h:intel_check_word.isra.0
   499    174     2    2     0    0    2    0    0    168    35   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-environ.c:_dl_next_ld_env_entry [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   479    161     7    4    44    0    4    1    0    152     9   .   .  /build/glibc-LcI20x/glibc-2.31/stdlib/getenv.c:getenv [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   474    174    30    5    37    0    5    4    0     60     .   .   .  /build/glibc-LcI20x/glibc-2.31/elf/../elf/dl-runtime.c:_dl_fixup [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   449    149    34    4     0    0    4    0    0     87     3  28   1  /build/glibc-LcI20x/glibc-2.31/libio/genops.c:_IO_default_xsputn [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   443     96    57   11     0    5   11    0    5     72    21   .   .  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/x86/dl-prop.h:_dl_process_pt_note [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   441    147     .    .     .    .    .    .    .      .     .   .   .  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/generic/ldsodefs.h:_dl_relocate_object
   439    130    51    3    21   27    3   21   27    114     5   .   .  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/x86_64/dl-machine.h:_dl_start
   434     94    64    0     2    6    0    1    6     79    35   .   .  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:mempcpy [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   422     35    65    2     2    0    2    2    0     29     2   .   .  /home/emilija/Desktop/password-manager-master/source/console/pm_rand.c:random_string [/home/emilija/Desktop/password-manager-master/pm]
   417    139     .    .     .    .    .    .    .      .     .   .   .  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/generic/ldsodefs.h:do_lookup_x
   413    123    35    6     0    0    6    0    0     59    19   .   .  /build/glibc-LcI20x/glibc-2.31/elf/./dl-map-segments.h:_dl_map_object_from_fd
   378     60    40    4     0    0    4    0    0     69    17   .   .  /build/glibc-LcI20x/glibc-2.31/misc/../sysdeps/unix/sysv/linux/mmap64.c:mmap [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   354     48     0    7     6    0    7    6    0     24     5   .   .  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/multiarch/../strchr.S:index [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   335     90    47   14    21    4   14    0    0     67    19   8   8  /build/glibc-LcI20x/glibc-2.31/elf/dl-fini.c:_dl_fini [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   329      7   297    4     0   38    4    0   38    290    10   .   .  /build/glibc-LcI20x/glibc-2.31/elf/../elf/dl-tls.c:_dl_allocate_tls_storage [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   328     50    38    7     8    6    7    8    6     87    24   .   .  /build/glibc-LcI20x/glibc-2.31/elf/get-dynamic-info.h:dl_main
   327     50    56   15     2    4   15    2    4     52    21   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-load.c:_dl_init_paths [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   317     89    67    4     1   11    4    1   11     59    24   .   .  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   310     86    46    2     4    6    2    0    6     42    10   .   .  /build/glibc-LcI20x/glibc-2.31/nptl/libc_pthread_init.c:__libc_pthread_init [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   309     63     0    1     8    0    1    8    0     54     8   .   .  /build/glibc-LcI20x/glibc-2.31/elf/do-rel.h:_dl_start
   274     13    22    3     0    2    3    0    2     39     7   .   .  /build/glibc-LcI20x/glibc-2.31/io/../sysdeps/unix/sysv/linux/open64_nocancel.c:__open_nocancel [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   273    134    34    3     2    4    3    2    4    100    14   .   .  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/strcspn.S:strcspn [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   253     61    13   12    12    0   12   12    0     47    19   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-load.c:open_verify.constprop.1 [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   251     48    27    7     0    1    7    0    1     56    14   .   .  /build/glibc-LcI20x/glibc-2.31/malloc/malloc.c:calloc [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   248     77     1    2     1    0    2    1    0     75    15   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-minimal.c:strsep [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   246    282   306    4     1   13    4    0    1      0     0   6   6  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   244     72    44    7     0    0    7    0    0     36     4   .   .  /build/glibc-LcI20x/glibc-2.31/malloc/malloc.c:_int_free [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   243     20    21   15     1    2   15    0    2     45    10   .   .  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86/cacheinfo.c:init_cacheinfo [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   238     36    26   10     7    7   10    7    7     62    18   .   .  /build/glibc-LcI20x/glibc-2.31/elf/get-dynamic-info.h:_dl_start
   226     79    38    4    18    0    4    0    0     25     6   8   8  /build/glibc-LcI20x/glibc-2.31/elf/dl-init.c:call_init.part.0 [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   210     42    78    3     0    4    3    0    4     12     1   6   2  /build/glibc-LcI20x/glibc-2.31/elf/dl-error-skeleton.c:_dl_catch_exception [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   204    153     0    1     1    0    1    .    .      .     .   .   .  /build/glibc-LcI20x/glibc-2.31/ctype/../include/ctype.h:__ctype_b_loc [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   177     36    45    5     0    0    5    0    0     15     3   .   .  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86/cacheinfo.c:handle_intel.constprop.0 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   174     34    58   19     3    2   19    0    1     51    17   .   .  /home/emilija/Desktop/password-manager-master/source/console/pm_parse.c:run [/home/emilija/Desktop/password-manager-master/pm]
   166     35    62    6     1    2    6    0    2      1     1   .   .  /build/glibc-LcI20x/glibc-2.31/setjmp/../sysdeps/x86_64/setjmp.S:__sigsetjmp [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   162     45    24    4     1    0    4    1    0     27     2   .   .  /build/glibc-LcI20x/glibc-2.31/stdlib/cxa_finalize.c:__cxa_finalize [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   157     23    51   12     5    7   12    0    3     24    12   .   .  /build/glibc-LcI20x/glibc-2.31/nptl/nptl-init.c:__pthread_initialize_minimal [/usr/lib/x86_64-linux-gnu/libpthread-2.31.so]
   156     33    36   13     0    1   13    0    1     25    15   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-load.c:fillin_rpath [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   155     37    35    3     0    0    3    0    0     13     7   8   2  /build/glibc-LcI20x/glibc-2.31/elf/dl-object.c:_dl_add_to_namespace_list [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   150     30    30    1     0    0    1    .    .      .     .   .   .  /build/glibc-LcI20x/glibc-2.31/stdlib/rand.c:rand [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   148     47    28   13     0    0   13    0    0     27     8   3   3  /build/glibc-LcI20x/glibc-2.31/libio/genops.c:_IO_cleanup [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   146     17    37   15     1    1   15    1    1     20     4   1   1  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/x86/cpu-features.c:_dl_sysdep_start
   144     33    24   14     4    2   14    1    2     21     7   2   2  /build/glibc-LcI20x/glibc-2.31/malloc/malloc.c:sysmalloc [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   120     35    30    3     6    1    3    6    1     10     1   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-lookup.c:_dl_setup_hash [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   118     36    21   10     8    1   10    3    1     23     6   2   2  /build/glibc-LcI20x/glibc-2.31/libio/genops.c:_IO_flush_all_lockp [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   115      0     0    0     0    0    0    0    0     28     .   .   .  /build/glibc-LcI20x/glibc-2.31/libio/libioP.h:_IO_default_xsputn
   112      7    85    3     0    9    3    0    9     85    10   .   .  /build/glibc-LcI20x/glibc-2.31/malloc/malloc.c:tcache_init.part.0 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
   109      8     7    1     0    0    1    0    0     16     3   .   .  /build/glibc-LcI20x/glibc-2.31/io/../sysdeps/unix/sysv/linux/wordsize-64/xstat.c:_xstat [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
   102     51     0    0     0    0    0    0    0      0     0  51   1  ???:0x000000000010a590 [???]
   102     28    24    7     0    4    7    0    1      8     2   .   .  /build/glibc-LcI20x/glibc-2.31/nptl/../sysdeps/unix/sysv/linux/sigaction.c:__libc_sigaction [/usr/lib/x86_64-linux-gnu/libpthread-2.31.so]
    99     12    23   10     0    1   10    0    1     16     5   .   .  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/x86/cpu-features.c:get_common_indices.constprop.0 [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    96     19    18    9     4    1    9    0    0     18     4   2   2  /build/glibc-LcI20x/glibc-2.31/stdlib/exit.c:__run_exit_handlers [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
    90     40    15    1     0    0    1    .    .      .     .   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-deps.c:openaux [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    90     30    30    2     0    1    2    0    1      5     .   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-load.c:_dl_dst_count [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    90      0     0    1     0    0    1    0    0     10     9   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-minimal.c:calloc [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    89     27    12    4     3    0    4    0    0     14     7   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-init.c:_dl_init [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    89     18    10   12     7    0   12    5    0     18     7   .   .  /build/glibc-LcI20x/glibc-2.31/stdlib/../stdlib/strtol_l.c:____strtoul_l_internal [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
    85     27    13    6     5    0    6    0    0     12     2   .   .  /build/glibc-LcI20x/glibc-2.31/elf/../elf/dl-tls.c:_dl_allocate_tls_init [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    85     15     9    2     0    0    2    0    0     11    10   .   .  /build/glibc-LcI20x/glibc-2.31/elf/dl-version.c:_dl_check_all_versions [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    84     20     0    2     0    0    2    0    0     20     4   .   .  /build/glibc-LcI20x/glibc-2.31/malloc/malloc.c:free [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
    83     11    18    8     4    2    8    1    0      5     2   .   .  /build/glibc-LcI20x/glibc-2.31/malloc/arena.c:ptmalloc_init.part.0 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
    82     12     4    5     1    1    5    1    1     15     7   .   .  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/unix/sysv/linux/dl-sysdep.c:_dl_discover_osversion [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    80     20     9    6     2    0    6    2    0     17     3   .   .  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/x86/dl-prop.h:dl_main
    77     17    13    5     3    0    5    1    0     16     9   .   .  /build/glibc-LcI20x/glibc-2.31/elf/rtld.c:init_tls [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    77      7     0    4     0    0    4    0    0     14     3   .   .  /build/glibc-LcI20x/glibc-2.31/io/../sysdeps/unix/sysv/linux/wordsize-64/fxstat.c:_fxstat [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    76     24     4    3     0    0    3    0    0     26     8   .   .  /build/glibc-LcI20x/glibc-2.31/elf/./dl-load.h:_dl_map_object_from_fd
    74     17    18    6     2    6    5    0    6      5     1   .   .  /build/glibc-LcI20x/glibc-2.31/elf/rtld.c:_dl_start [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    72      8    16    1     0    0    1    0    0      4     1   .   .  /build/glibc-LcI20x/glibc-2.31/string/strdup.c:strdup [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    70     16    10    5     0    0    5    0    0     14     5   .   .  /build/glibc-LcI20x/glibc-2.31/nptl/../nptl/pthread_mutex_lock.c:pthread_mutex_lock [/usr/lib/x86_64-linux-gnu/libpthread-2.31.so]
    70     14     8    6     0    0    6    0    0      7     3   .   .  /build/glibc-LcI20x/glibc-2.31/elf/../elf/dl-tls.c:_dl_determine_tlsoffset [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    69     18     6    3     1    0    3    0    0     15     4   .   .  /build/glibc-LcI20x/glibc-2.31/nptl/register-atfork.c:__unregister_atfork [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
    68     15    15    5     0    2    5    0    2      6     1   .   .  /build/glibc-LcI20x/glibc-2.31/elf/rtld.c:handle_preload_list [/usr/lib/x86_64-linux-gnu/ld-2.31.so]
    68     14     8    3     0    1    3    0    0     10     1   .   .  /build/glibc-LcI20x/glibc-2.31/nptl/../sysdeps/unix/sysv/linux/open64.c:open [/usr/lib/x86_64-linux-gnu/libpthread-2.31.so]
    67     13     8    4     0    0    4    0    0     18     7   .   .  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
    65     17    13    4     0    0    4    0    0      8     4   1   1  /build/glibc-LcI20x/glibc-2.31/libio/fileops.c:_IO_do_write@@GLIBC_2.2.5 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
    62     18     7    6     1    0    6    0    0     11     5   1   1  /build/glibc-LcI20x/glibc-2.31/malloc/malloc.c:malloc [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
    62     14     8    5     2    0    4    0    0     16     6   .   .  /build/glibc-LcI20x/glibc-2.31/nptl/pthread_mutex_unlock.c:pthread_mutex_unlock [/usr/lib/x86_64-linux-gnu/libpthread-2.31.so]
    60     30     0    0     1    0    0    0    0      0     0  30   1  ???:0x000000000010a580 [???]
    60      0    30    .     .    .    .    .    .      .     .   .   .  /build/glibc-LcI20x/glibc-2.31/stdlib/../sysdeps/unix/sysv/linux/x86/lowlevellock.h:random
    59     16    18    5     1    0    5    0    0      7     2   2   2  /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:(below main) [/usr/lib/x86_64-linux-gnu/libc-2.31.so]
    59     14     8    6     2    0    6    1    0      7     2   1   1  /build/glibc-LcI20x/glibc-2.31/libio/fileops.c:_IO_file_xsputn@@GLIBC_2.2.5 [/usr/lib/x86_64-linux-gnu/libc-2.31.so]

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/emilija/Desktop/password-manager-master/source/console/pm_parse.c
--------------------------------------------------------------------------------
Ir  Dr  Dw I1mr D1mr D1mw ILmr DLmr DLmw Bc  Bcm Bi Bim 

-- line 11 ----------------------------------------
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  .   .  .    .    .    .    .    .    .   .   .  .   .  #include <string.h>
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  .   .  .    .    .    .    .    .    .   .   .  .   .  String sync_remote_url;
  .   .  .    .    .    .    .    .    .   .   .  .   .  extern const char *data_store;
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  .   .  .    .    .    .    .    .    .   .   .  .   .  int is_flag(char *arg, char *s, char *l)
  .   .  .    .    .    .    .    .    .   .   .  .   .  {
578 225  0   11    4    0   11    4    0 227  81  .   .      return (strcmp(s, arg) == 0) || (strcmp(l, arg) == 0);
  .   .  .    .    .    .    .    .    .   .   .  .   .  }
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  .   .  .    .    .    .    .    .    .   .   .  .   .  void parse_flags(Flags *f, int argc, char **argv)
 13   1  6    2    0    0    2    .    .   .   .  .   .  {
  1   .  .    .    .    .    .    .    .   .   .  .   .      Flag *prev = NULL;
 24   0  0    1    0    0    1    0    0   3   1  .   .      for (int i = 1; i < argc; i++)
  .   .  .    .    .    .    .    .    .   .   .  .   .      {
  .   .  .    .    .    .    .    .    .   .   .  .   .          Flag *flag = NULL;
 15   5  0    0    0    0    0    0    0   5   5  .   .          if (!f->data.exists && is_flag(argv[i], "-d", "--data"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->data;
 20  10  0    0    0    0    0    0    0   5   .  .   .          else if (!f->label.exists && is_flag(argv[i], "-l", "--label"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->label;
 20  10  0    1    0    0    1    0    0   5   .  .   .          else if (!f->help.exists && is_flag(argv[i], "-h", "--help"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->help;
 20  10  0    0    0    0    0    0    0   5   .  .   .          else if (!f->data_file.exists && is_flag(argv[i], "-df", "--data-file"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->data_file;
 18   8  0    0    0    0    0    0    0   5   2  .   .          else if (!f->generate_password.exists && is_flag(argv[i], "-gp", "--generate-password"))
  2   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->generate_password;
 16   8  0    0    0    0    0    0    0   4   .  .   .          else if (!f->key.exists && is_flag(argv[i], "-k", "--key"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->key;
 15   7  0    0    0    0    0    0    0   4   1  .   .          else if (!f->copy.exists && is_flag(argv[i], "-c", "--copy"))
  2   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->copy;
 12   6  0    0    0    0    0    0    0   3   .  .   .          else if (!f->delete_label.exists && is_flag(argv[i], "-dl", "--delete-label"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->delete_label;
 12   6  0    0    0    0    0    0    0   3   .  .   .          else if (!f->input.exists && is_flag(argv[i], "-i", "--input"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->input;
 10   4  0    0    0    0    0    0    0   3   2  .   .          else if (!f->key_file.exists && is_flag(argv[i], "-kf", "--key-file"))
  2   0  0    1    0    0    1    .    .   .   .  .   .              flag = &f->key_file;
  8   4  0    1    0    0    1    0    0   2   .  .   .          else if (!f->version.exists && is_flag(argv[i], "-v", "--version"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->version;
  8   4  0    1    0    0    1    0    0   2   .  .   .          else if (!f->output.exists && is_flag(argv[i], "-o", "--output"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->output;
  8   4  0    1    0    0    1    0    0   2   .  .   .          else if (!f->binary.exists && is_flag(argv[i], "-b", "--binary"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->binary;
  8   4  0    2    0    0    2    0    0   2   2  .   .          else if (!f->b64enc.exists && is_flag(argv[i], "-b64enc", "--base64-encode"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->b64enc;
  8   4  0    0    0    0    0    0    0   2   .  .   .          else if (!f->b64dec.exists && is_flag(argv[i], "-b64dec", "--base64-decode"))
  .   .  .    .    .    .    .    .    .   .   .  .   .              flag = &f->b64dec;
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  .   .  .    .    .    .    .    .    .   .   .  .   .          if (flag)
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              prev = flag;
  3   0  3    .    .    .    .    .    .   .   .  .   .              flag->exists = 1;
  9   0  0    0    0    0    0    0    0   3   .  .   .              if ((i + 1) >= argc)
  .   .  .    .    .    .    .    .    .   .   .  .   .                  continue;
  9   6  3    .    .    .    .    .    .   .   .  .   .              flag->value = argv[i + 1];
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
 32   8  6    2    0    0    2    0    0   6   .  .   .          else if (!prev || (prev->value && (strcmp(prev->value, argv[i]) != 0)))
 53  14  0    5    1    0    5    0    0   5   2  2   1  => ???:0x000000000010a400 (2x)
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              error("unknown flag: \"%s\"", argv[i]);
  .   .  .    .    .    .    .    .    .   .   .  .   .              exit(1);
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
  .   .  .    .    .    .    .    .    .   .   .  .   .      }
  8   7  .    .    .    .    .    .    .   .   .  .   .  }
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  .   .  .    .    .    .    .    .    .   .   .  .   .  int run(uint8_t *aes_key, int argc, char **argv)
 14   1  7    2    0    0    2    .    .   .   .  .   .  {
  2   0  2    0    0    1    0    0    1   .   .  .   .      sync_remote_url = (String){
  2   0  1    .    .    .    .    .    .   .   .  .   .          .data = (uint8_t *)getenv("PM_SYNC_REMOTE_URL"),
499 165  7    8   46    0    8    1    0 154  10  2   2  => ???:0x000000000010a2f0 (1x)
  .   .  .    .    .    .    .    .    .   .   .  .   .      };
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  2   0  0    1    0    0    1    0    0   1   1  .   .      if (sync_remote_url.data != 0)
  .   .  .    .    .    .    .    .    .   .   .  .   .          sync_remote_url.length = strlen((char *)sync_remote_url.data);
  .   .  .    .    .    .    .    .    .   .   .  .   .  
 34   0 30    0    0    0    0    0    0  30   7  .   .      Flags f = {0};
  5   0  1    .    .    .    .    .    .   .   .  .   .      parse_flags(&f, argc, argv);
934 355 18   28    5    0   28    4    0 296  96  2   1  => /home/emilija/Desktop/password-manager-master/source/console/pm_parse.c:parse_flags (1x)
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  3   1  0    1    0    0    1    0    0   1   .  .   .      if (f.help.exists)
  .   .  .    .    .    .    .    .    .   .   .  .   .      {
  .   .  .    .    .    .    .    .    .   .   .  .   .          fprintf(stdout, "%s\n", "\n"
  .   .  .    .    .    .    .    .    .   .   .  .   .                                  "./pm [flags]                      read or write data\n"
  .   .  .    .    .    .    .    .    .   .   .  .   .                                  "\n"
  .   .  .    .    .    .    .    .    .   .   .  .   .                                  "sync:                             set PM_SYNC_REMOTE_URL env var\n"
  .   .  .    .    .    .    .    .    .   .   .  .   .                                  "\n"
  .   .  .    .    .    .    .    .    .   .   .  .   .                                  "flags:\n"
  .   .  .    .    .    .    .    .    .   .   .  .   .                                  "\n"
-- line 95 ----------------------------------------
-- line 110 ----------------------------------------
  .   .  .    .    .    .    .    .    .   .   .  .   .                                  "-b       --binary                 binary mode\n"
  .   .  .    .    .    .    .    .    .   .   .  .   .                                  "-b64enc  --base64-encode [str]    base64 encode string to stdout, optional key\n"
  .   .  .    .    .    .    .    .    .   .   .  .   .                                  "-b64dec  --base64-decode [str]    base64 decode string to stdout, optional key\n"
  .   .  .    .    .    .    .    .    .   .   .  .   .                                  "-v       --version                display version\n"
  .   .  .    .    .    .    .    .    .   .   .  .   .                                  "-h       --help                   display help\n\n");
  .   .  .    .    .    .    .    .    .   .   .  .   .          return 0;
  .   .  .    .    .    .    .    .    .   .   .  .   .      }
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  3   1  0    0    0    0    0    0    0   1   .  .   .      if (f.version.exists)
  .   .  .    .    .    .    .    .    .   .   .  .   .      {
  .   .  .    .    .    .    .    .    .   .   .  .   .          fprintf(stdout, "%s %s\n", "password-manager",
  .   .  .    .    .    .    .    .    .   .   .  .   .  #ifdef PM_VERSION
  .   .  .    .    .    .    .    .    .   .   .  .   .                  STR(PM_VERSION)
  .   .  .    .    .    .    .    .    .   .   .  .   .  #else
  .   .  .    .    .    .    .    .    .   .   .  .   .                  "unknown"
  .   .  .    .    .    .    .    .    .   .   .  .   .  #endif // PM_VERSION
  .   .  .    .    .    .    .    .    .   .   .  .   .                  "\nPM_THREAD_COUNT=" STR(PM_THREAD_COUNT)
  .   .  .    .    .    .    .    .    .   .   .  .   .          );
  .   .  .    .    .    .    .    .    .   .   .  .   .          return 0;
  .   .  .    .    .    .    .    .    .   .   .  .   .      }
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  3   1  0    0    0    0    0    0    0   1   .  .   .      if (f.key.exists)
  .   .  .    .    .    .    .    .    .   .   .  .   .      {
  .   .  .    .    .    .    .    .    .   .   .  .   .          if (!f.key.value)
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              error("%s", "key flag called without key value");
  .   .  .    .    .    .    .    .    .   .   .  .   .              return 1;
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  .   .  .    .    .    .    .    .    .   .   .  .   .          size_t key_len = strlen(f.key.value);
  .   .  .    .    .    .    .    .    .   .   .  .   .          memcpy(aes_key, f.key.value, key_len < 32 ? key_len : 32);
  .   .  .    .    .    .    .    .    .   .   .  .   .      }
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  3   1  0    1    0    0    1    0    0   1   .  .   .      if (f.key_file.exists)
  .   .  .    .    .    .    .    .    .   .   .  .   .      {
  3   1  0    0    0    0    0    0    0   1   1  .   .          if (!f.key_file.value)
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              error("%s", "key-file flag called without filename");
  .   .  .    .    .    .    .    .    .   .   .  .   .              return 1;
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
  3   0  1    1    0    0    1    .    .   .   .  .   .          File kf = open_and_map_file(f.key_file.value, PM_READ_ONLY);
155  31 25   17    1    1   17    0    0  22   7  3   3  => /home/emilija/Desktop/password-manager-master/source/console/pm_io.c:open_and_map_file (1x)
  3   2  .    .    .    .    .    .    .   .   .  .   .          memcpy(aes_key, kf.start, kf.size < 32 ? kf.size : 32);
  8   3  4    1    0    0    1    0    0   1   .  .   .          UNMAP_AND_CLOSE_FILE(kf);
 35  10  3    5    1    0    5    0    0   5   0  2   2  => /home/emilija/Desktop/password-manager-master/source/console/pm_io.c:unmap_and_close_file (1x)
  .   .  .    .    .    .    .    .    .   .   .  .   .      }
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  5   2  0    0    0    0    0    0    0   2   1  .   .      if (f.copy.value && !f.label.value)
  .   .  .    .    .    .    .    .    .   .   .  .   .      {
  1   0  1    1    0    0    1    .    .   .   .  .   .          f.label.exists = 1;
  1   0  1    1    0    0    1    .    .   .   .  .   .          f.label.value = f.copy.value;
  .   .  .    .    .    .    .    .    .   .   .  .   .      }
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  3   1  0    0    0    0    0    0    0   1   1  .   .      if (f.input.exists)
  .   .  .    .    .    .    .    .    .   .   .  .   .      {
  .   .  .    .    .    .    .    .    .   .   .  .   .          if (f.input.value)
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              data_store = f.input.value;
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
  .   .  .    .    .    .    .    .    .   .   .  .   .          else
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              error("%s", "input flag called without file path");
  .   .  .    .    .    .    .    .    .   .   .  .   .              return 1;
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
  .   .  .    .    .    .    .    .    .   .   .  .   .      }
  .   .  .    .    .    .    .    .    .   .   .  .   .      else
  .   .  .    .    .    .    .    .    .   .   .  .   .      {
  2   0  1    1    0    0    1    .    .   .   .  .   .          data_store = DEFAULT_DATA_STORE;
  .   .  .    .    .    .    .    .    .   .   .  .   .      }
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  3   1  0    0    0    0    0    0    0   1   1  .   .      if (f.delete_label.exists)
  .   .  .    .    .    .    .    .    .   .   .  .   .      {
  .   .  .    .    .    .    .    .    .   .   .  .   .          if (f.delete_label.value)
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              delete_label(&f, PM_STR(f.delete_label.value), aes_key);
  .   .  .    .    .    .    .    .    .   .   .  .   .              return 0;
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
  .   .  .    .    .    .    .    .    .   .   .  .   .          else
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              error("%s", "delete-label flag called without label");
  .   .  .    .    .    .    .    .    .   .   .  .   .              return 1;
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
  .   .  .    .    .    .    .    .    .   .   .  .   .      }
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  3   1  0    1    0    0    1    0    0   1   1  .   .      if (!f.data.exists)
  .   .  .    .    .    .    .    .    .   .   .  .   .      {
  3   1  0    1    0    0    1    0    0   1   1  .   .          if (f.data_file.exists)
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  .   .  .    .    .    .    .    .    .   .   .  .   .              if (f.generate_password.exists)
  .   .  .    .    .    .    .    .    .   .   .  .   .              {
  .   .  .    .    .    .    .    .    .   .   .  .   .                  error("%s", "can't combine data-file and "
  .   .  .    .    .    .    .    .    .   .   .  .   .                              "generate-password flags");
  .   .  .    .    .    .    .    .    .   .   .  .   .                  return 1;
  .   .  .    .    .    .    .    .    .   .   .  .   .              }
-- line 202 ----------------------------------------
-- line 240 ----------------------------------------
  .   .  .    .    .    .    .    .    .   .   .  .   .                  encrypt_and_replace(&f, s, PM_STR(f.label.value), aes_key);
  .   .  .    .    .    .    .    .    .   .   .  .   .              else
  .   .  .    .    .    .    .    .    .   .   .  .   .                  encrypt_and_write(&f, s, aes_key);
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  .   .  .    .    .    .    .    .    .   .   .  .   .              free(s.data);
  .   .  .    .    .    .    .    .    .   .   .  .   .              UNMAP_AND_CLOSE_FILE(file);
  .   .  .    .    .    .    .    .    .   .   .  .   .              return 0;
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
  3   1  0    1    0    0    1    0    0   1   1  .   .          if (f.b64enc.exists && f.b64enc.value)
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              String str = PM_STR(f.b64enc.value);
  .   .  .    .    .    .    .    .    .   .   .  .   .              b64_encrypt(&f, str, aes_key);
  .   .  .    .    .    .    .    .    .   .   .  .   .              return 0;
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
  3   1  0    1    0    0    1    0    0   1   .  .   .          if (f.b64dec.exists && f.b64dec.value)
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              String str = PM_STR(f.b64dec.value);
  .   .  .    .    .    .    .    .    .   .   .  .   .              b64_decrypt(&f, str, aes_key);
  .   .  .    .    .    .    .    .    .   .   .  .   .              return 0;
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
  3   1  0    1    0    0    1    0    0   1   .  .   .          if (f.generate_password.exists)
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              unsigned long password_length;
  3   1  0    0    0    0    0    0    0   1   .  .   .              if (f.generate_password.value)
  .   .  .    .    .    .    .    .    .   .   .  .   .              {
  4   0  1    .    .    .    .    .    .   .   .  .   .                  password_length = strtoul(f.generate_password.value, NULL, 10);
 96  21 10   14    7    0   14    5    0  18   7  1   1  => ???:0x000000000010a510 (1x)
  2   0  0    0    0    0    0    0    0   1   1  .   .                  if (password_length == 0)
  .   .  .    .    .    .    .    .    .   .   .  .   .                  {
  .   .  .    .    .    .    .    .    .   .   .  .   .                      password_length = (unsigned long)random_int();
  .   .  .    .    .    .    .    .    .   .   .  .   .                  }
  .   .  .    .    .    .    .    .    .   .   .  .   .                  else if (!(password_length <= INT_MAX))
  .   .  .    .    .    .    .    .    .   .   .  .   .                  {
  .   .  .    .    .    .    .    .    .   .   .  .   .                      error("length %s is out of range 1-%d\n",
  .   .  .    .    .    .    .    .    .   .   .  .   .                            f.generate_password.value, INT_MAX);
  .   .  .    .    .    .    .    .    .   .   .  .   .                      return 1;
  .   .  .    .    .    .    .    .    .   .   .  .   .                  }
  .   .  .    .    .    .    .    .    .   .   .  .   .              }
  .   .  .    .    .    .    .    .    .   .   .  .   .              else
  .   .  .    .    .    .    .    .    .   .   .  .   .              {
  4   0  1    1    0    0    1    .    .   .   .  .   .                  password_length = (unsigned long)random_int();
6,964 1,597 677   16    1    3   16    0    3 984  35  4   3  => /home/emilija/Desktop/password-manager-master/source/console/pm_rand.c:random_int (1x)
  .   .  .    .    .    .    .    .    .   .   .  .   .              }
  4   0  1    1    0    0    1    .    .   .   .  .   .              uint8_t *password_data = (uint8_t *)malloc(password_length + 1);
75,184 15,095 635   85 1,194   79   85  847   46 16,353 2,118 24  12  => ???:0x000000000010a430 (1x)
  3   0  1    .    .    .    .    .    .   .   .  .   .              random_string(password_length, password_data);
8,979 2,073 946    2    6    3    2    2    0 1,219  30 30   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_rand.c:random_string (1x)
  .   .  .    .    .    .    .    .    .   .   .  .   .              String password = {
  .   .  .    .    .    .    .    .    .   .   .  .   .                  .data = password_data,
  .   .  .    .    .    .    .    .    .   .   .  .   .                  .length = password_length,
  .   .  .    .    .    .    .    .    .   .   .  .   .              };
  3   1  0    0    1    0    0    0    0   1   .  .   .              if (f.label.exists)
 11   2  3    1    0    1    1    .    .   .   .  .   .                  encrypt_and_replace(&f, password, PM_STR(f.label.value), aes_key);
48,935 9,091 5,694  123   16    4  122    7    3 4,844 306 72   8  => /home/emilija/Desktop/password-manager-master/source/console/pm_xcrypt.c:encrypt_and_replace (1x)
 18   3  0    0    2    0    0    0    0   2   1  1   1  => ???:0x000000000010a340 (1x)
  .   .  .    .    .    .    .    .    .   .   .  .   .              else
  .   .  .    .    .    .    .    .    .   .   .  .   .                  encrypt_and_write(&f, password, aes_key);
  3   1  0    0    0    0    0    0    0   1   1  .   .              if (f.copy.exists)
  4   0  1    1    0    0    1    .    .   .   .  .   .                  copy_to_clipboard(password.data, password_length + 1);
2,247 566 288   59   10    1   59    2    1 437  40 37  10  => /home/emilija/Desktop/password-manager-master/source/console/pm_io.c:copy_to_clipboard (1x)
  2   0  1    .    .    .    .    .    .   .   .  .   .              free(password_data);
 84  24 11    0    0    0    0    0    0  14   1  1   .  => ???:0x000000000010a300 (1x)
  1   .  .    .    .    .    .    .    .   .   .  .   .              return 0;
  .   .  .    .    .    .    .    .    .   .   .  .   .          }
  .   .  .    .    .    .    .    .    .   .   .  .   .          if (f.label.exists)
  .   .  .    .    .    .    .    .    .   .   .  .   .          {
  .   .  .    .    .    .    .    .    .   .   .  .   .              if (!f.label.value)
  .   .  .    .    .    .    .    .    .   .   .  .   .              {
  .   .  .    .    .    .    .    .    .   .   .  .   .                  error("%s", "label flag called without value");
  .   .  .    .    .    .    .    .    .   .   .  .   .                  return 1;
  .   .  .    .    .    .    .    .    .   .   .  .   .              }
-- line 302 ----------------------------------------
-- line 358 ----------------------------------------
  .   .  .    .    .    .    .    .    .   .   .  .   .          encrypt_and_replace(&f, PM_STR(f.data.value), PM_STR(f.label.value), aes_key);
  .   .  .    .    .    .    .    .    .   .   .  .   .      }
  .   .  .    .    .    .    .    .    .   .   .  .   .      else
  .   .  .    .    .    .    .    .    .   .   .  .   .      {
  .   .  .    .    .    .    .    .    .   .   .  .   .          encrypt_and_write(&f, PM_STR(f.data.value), aes_key);
  .   .  .    .    .    .    .    .    .   .   .  .   .      }
  .   .  .    .    .    .    .    .    .   .   .  .   .  
  .   .  .    .    .    .    .    .    .   .   .  .   .      return 0;
 12   9  0    0    2    0    0    0    0   1   .  .   .  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/emilija/Desktop/password-manager-master/source/console/pm_rand.c
--------------------------------------------------------------------------------
Ir  Dr Dw I1mr D1mr D1mw ILmr DLmr DLmw Bc Bcm Bi Bim 

-- line 2 ----------------------------------------
  .  .  .    .    .    .    .    .    .  .   .  .   .  // PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com
  .  .  .    .    .    .    .    .    .  .   .  .   .  
  .  .  .    .    .    .    .    .    .  .   .  .   .  #include "console/rand.h"
  .  .  .    .    .    .    .    .    .  .   .  .   .  
  .  .  .    .    .    .    .    .    .  .   .  .   .  #include <stdlib.h>
  .  .  .    .    .    .    .    .    .  .   .  .   .  #include <time.h>
  .  .  .    .    .    .    .    .    .  .   .  .   .  
  .  .  .    .    .    .    .    .    .  .   .  .   .  int random_int()
  2  0  0    1    0    0    1    .    .  .   .  .   .  {
  4  0  2    1    0    0    1    .    .  .   .  .   .      srand((unsigned int)time(NULL));
6,817 1,560 657    8    1    3    8    0    3 966  31  1   1  => ???:0x000000000010a3d0 (1x)
  8  2  0    0    0    0    0    0    0  1   0  1   1  => ???:0x000000000010a420 (1x)
  1  0  1    .    .    .    .    .    .  .   .  .   .      rand();
 62 17  8    6    0    0    6    0    0  8   2  1   1  => ???:0x000000000010a580 (1x)
  .  .  .    .    .    .    .    .    .  .   .  .   .      int x = 33;
  3  0  0    0    0    0    0    0    0  1   .  .   .      while (x > 32)
  3  0  1    .    .    .    .    .    .  .   .  .   .          x = 16 + rand() / ((RAND_MAX + 1u) / 32);
 62 17  8    0    0    0    0    0    0  8   2  1   .  => ???:0x000000000010a580 (1x)
  .  .  .    .    .    .    .    .    .  .   .  .   .      return x;
  2  1  .    .    .    .    .    .    .  .   .  .   .  }
  .  .  .    .    .    .    .    .    .  .   .  .   .  
  .  .  .    .    .    .    .    .    .  .   .  .   .  void random_string(size_t sz, uint8_t *out)
 10  0  6    1    0    0    1    .    .  .   .  .   .  {
  4  0  2    .    .    .    .    .    .  .   .  .   .      srand((unsigned int)time(NULL));
6,817 1,560 657    0    2    3    0    0    0 966  21  1   .  => ???:0x000000000010a3d0 (1x)
  8  2  0    0    1    0    0    0    0  1   0  1   .  => ???:0x000000000010a420 (1x)
  .  .  .    .    .    .    .    .    .  .   .  .   .      static char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX"
  .  .  .    .    .    .    .    .    .  .   .  .   .                              "YZ0123456789!@#$%^&*()-+";
  .  .  .    .    .    .    .    .    .  .   .  .   .      size_t l = sizeof(charset) - 1;
 61  0  0    0    0    0    0    0    0 29   2  .   .      for (size_t n = 0; n < sz; n++)
338 28 56    1    2    0    1    2    .  .   .  .   .          out[n] = charset[rand() % l];
1,732 476 224    0    1    0    0    0    0 223   7 28   .  => ???:0x000000000010a580 (28x)
  1  0  1    .    .    .    .    .    .  .   .  .   .      out[sz] = '\0';
  8  7  .    .    .    .    .    .    .  .   .  .   .  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/emilija/Desktop/password-manager-master/source/console/pm_xcrypt.c
--------------------------------------------------------------------------------
Ir  Dr  Dw I1mr D1mr D1mw ILmr DLmr DLmw Bc Bcm Bi Bim 

-- line 31 ----------------------------------------
  .   .  .    .    .    .    .    .    .  .   .  .   .      if (fl->key.exists || fl->key_file.exists)
  .   .  .    .    .    .    .    .    .  .   .  .   .          xcrypt_buffer(b64_decoded_str, aes_key, b64_decoded_len);
  .   .  .    .    .    .    .    .    .  .   .  .   .      if (fwrite(b64_decoded_str, 1, b64_decoded_len, stdout) != b64_decoded_len)
  .   .  .    .    .    .    .    .    .  .   .  .   .          error("%s", "fwrite failed");
  .   .  .    .    .    .    .    .    .  .   .  .   .      free(b64_decoded_str);
  .   .  .    .    .    .    .    .    .  .   .  .   .  }
  .   .  .    .    .    .    .    .    .  .   .  .   .  
  .   .  .    .    .    .    .    .    .  .   .  .   .  void encrypt_and_replace(Flags *fl, String s, String label, uint8_t *aes_key)
 17   1 10    2    0    0    2    .    .  .   .  .   .  {
  3   2  1    0    1    .    .    .    .  .   .  .   .      pull_changes(sync_remote_url);
 40  14 11    7    0    1    7    0    0  3   2  .   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_sync.c:pull_changes (1x)
  .   .  .    .    .    .    .    .    .  .   .  .   .  
  5   1  1    .    .    .    .    .    .  .   .  .   .      File f = create_file(data_store, PM_READ_WRITE);
138  31 24    6    1    0    6    0    0 16   4  3   2  => /home/emilija/Desktop/password-manager-master/source/console/pm_io.c:create_file (1x)
  3   0  1    .    .    .    .    .    .  .   .  .   .      input_key(aes_key, fl);
  8   3  0    2    2    0    2    0    0  2   1  .   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_io.c:input_key (1x)
  .   .  .    .    .    .    .    .    .  .   .  .   .  
  2   1  0    0    0    0    0    0    0  1   1  .   .      if (f.size == 0)
  .   .  .    .    .    .    .    .    .  .   .  .   .          goto append;
  .   .  .    .    .    .    .    .    .  .   .  .   .      else
  5   0  1    1    0    0    1    0    0  1   .  .   .          MAP_FILE_(&f);
 43   9  5    2    0    0    2    0    0  6   3  1   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_io.c:map_file (1x)
  .   .  .    .    .    .    .    .    .  .   .  .   .  
  1   .  .    .    .    .    .    .    .  .   .  .   .      size_t line_start = 0;
  .   .  .    .    .    .    .    .    .  .   .  .   .      size_t line_end = 0;
  .   .  .    .    .    .    .    .    .  .   .  .   .      do
  .   .  .    .    .    .    .    .    .  .   .  .   .      {
159 106  0    1    1    0    1    0    0 53   5  .   .          if (f.start[line_end] == '\n')
  .   .  .    .    .    .    .    .    .  .   .  .   .          {
  2   .  .    .    .    .    .    .    .  .   .  .   .              size_t line_len = line_end - line_start;
  .   .  .    .    .    .    .    .    .  .   .  .   .              size_t b64_decoded_len;
 63   1  4    .    .    .    .    .    .  .   .  .   .              uint8_t *b64_decoded_str = b64_decode(f.start + line_start, line_len, &b64_decoded_len);
12,893 2,363 297   24    5    0   24    2    0 3,860 151 53   3  => /home/emilija/Desktop/password-manager-master/source/console/pm_b64.c:b64_decode (1x)
  2   1  1    .    .    .    .    .    .  .   .  .   .              xcrypt_buffer(b64_decoded_str, aes_key, b64_decoded_len);
  7   1  1    0    0    0    0    0    0  2   1  .   .              if ((label.length + 1 >= b64_decoded_len) ||
  4   1  1    1    0    0    1    .    .  .   .  .   .                  (memcmp(b64_decoded_str, label.data, label.length) != 0))
 29   6  0    3    0    0    3    0    0  8   1  1   1  => ???:0x000000000010a3e0 (1x)
  .   .  .    .    .    .    .    .    .  .   .  .   .                  goto skip_line;
  2   .  .    .    .    .    .    .    .  .   .  .   .              size_t label_len = 0;
 48  12  0    0    0    0    0    0    0 12   7  .   .              while (b64_decoded_str[++label_len] != ' ')
 22   0  0    0    0    0    0    0    0 11   1  .   .                  if (label_len > b64_decoded_len)
  .   .  .    .    .    .    .    .    .  .   .  .   .                      goto skip_line;
  2   0  0    0    0    0    0    0    0  1   .  .   .              if (label_len != label.length)
  .   .  .    .    .    .    .    .    .  .   .  .   .                  goto skip_line;
  5   2  1    .    .    .    .    .    .  .   .  .   .              size_t label_and_data_length = label_len + 1 + s.length;
  9   1  4    1    0    0    1    .    .  .   .  .   .              uint8_t *label_and_data = (uint8_t *)calloc(1, label_and_data_length);
227  41 33    0    0    1    0    0    1 38  11  1   .  => ???:0x000000000010a3f0 (1x)
  4   2  0    0    0    0    0    0    0  1   .  .   .              ASSERT_ALLOC(label_and_data);
  1   .  .    .    .    .    .    .    .  .   .  .   .              memcpy(label_and_data, b64_decoded_str, label_len + 1);
  2   1  .    .    .    .    .    .    .  .   .  .   .              memcpy(label_and_data + label_len + 1, s.data, s.length);
  .   .  .    .    .    .    .    .    .  .   .  .   .              xcrypt_buffer(label_and_data, aes_key, label_and_data_length);
  .   .  .    .    .    .    .    .    .  .   .  .   .              size_t b64_encoded_len;
  6   1  1    .    .    .    .    .    .  .   .  .   .              char *b64_encoded_str = b64_encode(label_and_data, label_and_data_length, &b64_encoded_len);
1,221 186 139   10    0    2   10    0    2 130   8  1   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_b64.c:b64_encode (1x)
  3   2  0    0    0    0    0    0    0  1   .  .   .              if (b64_encoded_len == line_len)
  .   .  .    .    .    .    .    .    .  .   .  .   .              {
  .   .  .    .    .    .    .    .    .  .   .  .   .                  memcpy(f.start + line_start, b64_encoded_str, b64_encoded_len);
  .   .  .    .    .    .    .    .    .  .   .  .   .                  UNMAP_AND_CLOSE_FILE(f);
  .   .  .    .    .    .    .    .    .  .   .  .   .              }
  .   .  .    .    .    .    .    .    .  .   .  .   .              else
  .   .  .    .    .    .    .    .    .  .   .  .   .              {
  1   1  0    1    0    0    1    .    .  .   .  .   .                  size_t initial_size = f.size;
  1   0  0    0    0    0    0    0    0  1   1  .   .                  if (b64_encoded_len > line_len)
  .   .  .    .    .    .    .    .    .  .   .  .   .                  {
  4   0  2    .    .    .    .    .    .  .   .  .   .                      size_t b64_len_diff = b64_encoded_len - line_len;
  9   4  4    2    0    0    2    0    0  1   .  .   .                      UNMAP_FILE(f);
 19   5  1    3    0    0    2    0    0  2   0  1   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_io.c:unmap_file (1x)
  6   2  1    0    0    0    0    0    0  1   .  .   .                      TRUNCATE_FILE(&f, f.size + b64_len_diff);
 24   6  4    2    0    0    2    0    0  2   0  1   1  => /home/emilija/Desktop/password-manager-master/source/console/pm_io.c:truncate_file (1x)
  4   0  1    0    0    0    0    0    0  1   .  .   .                      MAP_FILE_(&f);
 43   9  5    0    0    0    0    0    0  6   2  1   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_io.c:map_file (1x)
  6   2  0    1    0    0    1    .    .  .   .  .   .                      memcpy(f.start + line_end + 1 + b64_len_diff, f.start + line_end + 1, initial_size - line_end - 1);
  2   2  .    .    .    .    .    .    .  .   .  .   .                      memcpy(f.start + line_start, b64_encoded_str, b64_encoded_len);
  4   3  1    1    0    0    1    .    .  .   .  .   .                      f.start[line_start + b64_encoded_len] = '\n';
 10   4  4    0    0    0    0    0    0  1   .  .   .                      UNMAP_AND_CLOSE_FILE(f);
 35  10  3    0    0    0    0    0    0  5   0  2   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_io.c:unmap_and_close_file (1x)
  .   .  .    .    .    .    .    .    .  .   .  .   .                  }
  2   1  0    0    0    0    0    0    0  1   .  .   .                  if (b64_encoded_len < line_len)
  .   .  .    .    .    .    .    .    .  .   .  .   .                  {
  .   .  .    .    .    .    .    .    .  .   .  .   .                      size_t b64_len_diff = line_len - b64_encoded_len;
  .   .  .    .    .    .    .    .    .  .   .  .   .                      memcpy(f.start + line_start, b64_encoded_str, b64_encoded_len);
  .   .  .    .    .    .    .    .    .  .   .  .   .                      f.start[line_start + b64_encoded_len] = '\n';
  .   .  .    .    .    .    .    .    .  .   .  .   .                      memcpy(f.start + line_start + b64_encoded_len + 1, f.start + line_end + 1, initial_size - line_end - 1);
  .   .  .    .    .    .    .    .    .  .   .  .   .                      UNMAP_FILE(f);
  .   .  .    .    .    .    .    .    .  .   .  .   .                      TRUNCATE_FILE(&f, f.size - b64_len_diff);
  .   .  .    .    .    .    .    .    .  .   .  .   .                      CLOSE_FILE(f.handle);
  .   .  .    .    .    .    .    .    .  .   .  .   .                  }
  .   .  .    .    .    .    .    .    .  .   .  .   .              }
  2   0  1    1    0    0    1    .    .  .   .  .   .              free(b64_decoded_str);
 84  24 11   10    0    0   10    0    0 14   3  1   1  => ???:0x000000000010a300 (1x)
  2   0  1    .    .    .    .    .    .  .   .  .   .              free(label_and_data);
 84  24 11    0    0    0    0    0    0 14   3  1   .  => ???:0x000000000010a300 (1x)
  2   0  1    .    .    .    .    .    .  .   .  .   .              free(b64_encoded_str);
 84  24 11    0    0    0    0    0    0 14   1  1   .  => ???:0x000000000010a300 (1x)
  1   .  .    .    .    .    .    .    .  .   .  .   .              goto end;
  .   .  .    .    .    .    .    .    .  .   .  .   .          skip_line:
  .   .  .    .    .    .    .    .    .  .   .  .   .              line_start = line_end + 1;
  .   .  .    .    .    .    .    .    .  .   .  .   .              free(b64_decoded_str);
  .   .  .    .    .    .    .    .    .  .   .  .   .          }
  .   .  .    .    .    .    .    .    .  .   .  .   .          line_end++;
104  52  0    0    0    0    0    0    0 52   .  .   .      } while (line_end < f.size);
  .   .  .    .    .    .    .    .    .  .   .  .   .  
  1   1  0    1    0    0    1    .    .  .   .  .   .  append:
  .   .  .    .    .    .    .    .    .  .   .  .   .  {
  .   .  .    .    .    .    .    .    .  .   .  .   .      size_t label_and_data_length = label.length + 1 + s.length;
  .   .  .    .    .    .    .    .    .  .   .  .   .      uint8_t *label_and_data = (uint8_t *)calloc(1, label_and_data_length);
  .   .  .    .    .    .    .    .    .  .   .  .   .      ASSERT_ALLOC(label_and_data);
  .   .  .    .    .    .    .    .    .  .   .  .   .  
  .   .  .    .    .    .    .    .    .  .   .  .   .      memcpy(label_and_data, label.data, label.length);
  .   .  .    .    .    .    .    .    .  .   .  .   .      label_and_data[label.length] = ' ';
  .   .  .    .    .    .    .    .    .  .   .  .   .      memcpy(label_and_data + label.length + 1, s.data, s.length);
-- line 126 ----------------------------------------
-- line 135 ----------------------------------------
  .   .  .    .    .    .    .    .    .  .   .  .   .      memcpy(f.start + initial_size, b64_encoded_str, b64_encoded_len);
  .   .  .    .    .    .    .    .    .  .   .  .   .      f.start[initial_size + b64_encoded_len] = '\n';
  .   .  .    .    .    .    .    .    .  .   .  .   .  
  .   .  .    .    .    .    .    .    .  .   .  .   .      free(label_and_data);
  .   .  .    .    .    .    .    .    .  .   .  .   .      free(b64_encoded_str);
  .   .  .    .    .    .    .    .    .  .   .  .   .  }
  .   .  .    .    .    .    .    .    .  .   .  .   .      UNMAP_AND_CLOSE_FILE(f);
  .   .  .    .    .    .    .    .    .  .   .  .   .  end:
  3   2  1    1    0    0    1    .    .  .   .  .   .      upload_changes(sync_remote_url);
 40  14 11    2    0    0    2    0    0  3   2  .   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_sync.c:upload_changes (1x)
 11   9  0    0    0    0    0    0    0  1   .  .   .  }
  .   .  .    .    .    .    .    .    .  .   .  .   .  
  .   .  .    .    .    .    .    .    .  .   .  .   .  #if PM_THREAD_COUNT > 1
  .   .  .    .    .    .    .    .    .  .   .  .   .  static void xcrypt_in_parallel(void *(routine)(void *), void *user_ctx, size_t size)
  .   .  .    .    .    .    .    .    .  .   .  .   .  {
  .   .  .    .    .    .    .    .    .  .   .  .   .      thread_load_info tl = calc_thread_load(PM_THREAD_COUNT, size);
  .   .  .    .    .    .    .    .    .  .   .  .   .      tl.user_ctx = user_ctx;
  .   .  .    .    .    .    .    .    .  .   .  .   .      og_thread_t threads[PM_THREAD_COUNT];
  .   .  .    .    .    .    .    .    .  .   .  .   .      int i = 0;
-- line 152 ----------------------------------------
-- line 281 ----------------------------------------
  .   .  .    .    .    .    .    .    .  .   .  .   .      UNMAP_AND_CLOSE_FILE(f);
  .   .  .    .    .    .    .    .    .  .   .  .   .  end:
  .   .  .    .    .    .    .    .    .  .   .  .   .      upload_changes(sync_remote_url);
  .   .  .    .    .    .    .    .    .  .   .  .   .  }
  .   .  .    .    .    .    .    .    .  .   .  .   .  
  .   .  .    .    .    .    .    .    .  .   .  .   .  void xcrypt_buffer(uint8_t *line, uint8_t *aes_key, size_t length)
  .   .  .    .    .    .    .    .    .  .   .  .   .  {
  .   .  .    .    .    .    .    .    .  .   .  .   .      struct AES_ctx ctx;
  9   1  2    1    0    0    1    .    .  .   .  .   .      AES_init_ctx_iv(&ctx, aes_key, aes_iv);
2,080 558 430    5    6    0    5    5    0 300  39  .   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_aes.c:AES_init_ctx_iv (2x)
 11   2  3    1    0    0    1    .    .  .   .  .   .      AES_CTR_xcrypt_buffer(&ctx, line, length);
31,201 5,525 4,637   30    0    0   30    0    0 266  53  .   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_aes.c:AES_CTR_xcrypt_buffer (2x)
  .   .  .    .    .    .    .    .    .  .   .  .   .  }
  .   .  .    .    .    .    .    .    .  .   .  .   .  
  .   .  .    .    .    .    .    .    .  .   .  .   .  void decrypt_and_print(Flags *fl, uint8_t *aes_key)
  .   .  .    .    .    .    .    .    .  .   .  .   .  {
  .   .  .    .    .    .    .    .    .  .   .  .   .      pull_changes(sync_remote_url);
  .   .  .    .    .    .    .    .    .  .   .  .   .      FILE *o;
  .   .  .    .    .    .    .    .    .  .   .  .   .      if (fl->output.exists)
  .   .  .    .    .    .    .    .    .  .   .  .   .      {
-- line 298 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/emilija/Desktop/password-manager-master/source/console/pm_aes.c
--------------------------------------------------------------------------------
Ir    Dr    Dw    I1mr D1mr D1mw ILmr DLmr DLmw Bc  Bcm Bi Bim 

-- line 155 ----------------------------------------
    .     .     .    .    .    .    .    .    .   .   .  .   .  #define getSBoxValue(num) (sbox[(num)])
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  uint8_t aes_iv[] = {0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
    .     .     .    .    .    .    .    .    .   .   .  .   .                      0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  // This function produces Nb(Nr+1) round keys. The round keys are used in each
    .     .     .    .    .    .    .    .    .   .   .  .   .  // round to decrypt the states.
    .     .     .    .    .    .    .    .    .   .   .  .   .  static void KeyExpansion(uint8_t *RoundKey, const uint8_t *Key)
    8     0     2    0    0    0    0    0    0   2   .  .   .  {
    .     .     .    .    .    .    .    .    .   .   .  .   .      unsigned i, j, k;
    .     .     .    .    .    .    .    .    .   .   .  .   .      uint8_t tempa[4]; // Used for the column/row operations
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .      // The first round key is the key itself.
    6     4     0    1    0    0    1    .    .   .   .  .   .      for (i = 0; i < Nk; ++i)
    .     .     .    .    .    .    .    .    .   .   .  .   .      {
    8     4     4    .    .    .    .    .    .   .   .  .   .          RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    .     .     .    .    .    .    .    .    .   .   .  .   .          RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    .     .     .    .    .    .    .    .    .   .   .  .   .          RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    .     .     .    .    .    .    .    .    .   .   .  .   .          RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
    .     .     .    .    .    .    .    .    .   .   .  .   .      }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .      // All other round keys are found from the previous round keys.
  418     0     0    0    0    0    0    0    0 104   2  .   .      for (i = Nk; i < Nb * (Nr + 1); ++i)
    .     .     .    .    .    .    .    .    .   .   .  .   .      {
    .     .     .    .    .    .    .    .    .   .   .  .   .          {
    .     .     .    .    .    .    .    .    .   .   .  .   .              k = (i - 1) * 4;
    .     .     .    .    .    .    .    .    .   .   .  .   .              tempa[0] = RoundKey[k + 0];
    .     .     .    .    .    .    .    .    .   .   .  .   .              tempa[1] = RoundKey[k + 1];
    .     .     .    .    .    .    .    .    .   .   .  .   .              tempa[2] = RoundKey[k + 2];
    .     .     .    .    .    .    .    .    .   .   .  .   .              tempa[3] = RoundKey[k + 3];
    .     .     .    .    .    .    .    .    .   .   .  .   .          }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
  312     0     0    1    0    0    1    0    0 104  14  .   .          if (i % Nk == 0)
    .     .     .    .    .    .    .    .    .   .   .  .   .          {
    .     .     .    .    .    .    .    .    .   .   .  .   .              // This function shifts the 4 bytes in a word to the left once.
    .     .     .    .    .    .    .    .    .   .   .  .   .              // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .              // Function RotWord()
    .     .     .    .    .    .    .    .    .   .   .  .   .              {
    .     .     .    .    .    .    .    .    .   .   .  .   .                  const uint8_t u8tmp = tempa[0];
    .     .     .    .    .    .    .    .    .   .   .  .   .                  tempa[0] = tempa[1];
-- line 195 ----------------------------------------
-- line 199 ----------------------------------------
    .     .     .    .    .    .    .    .    .   .   .  .   .              }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .              // SubWord() is a function that takes a four-byte input word and
    .     .     .    .    .    .    .    .    .   .   .  .   .              // applies the S-box to each of the four bytes to produce an output
    .     .     .    .    .    .    .    .    .   .   .  .   .              // word.
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .              // Function Subword()
    .     .     .    .    .    .    .    .    .   .   .  .   .              {
   28    14     0    0    1    0    0    1    .   .   .  .   .                  tempa[0] = getSBoxValue(tempa[0]);
   28    14     0    0    1    0    0    1    .   .   .  .   .                  tempa[1] = getSBoxValue(tempa[1]);
   28    14     .    .    .    .    .    .    .   .   .  .   .                  tempa[2] = getSBoxValue(tempa[2]);
   28    14     0    0    1    0    0    1    .   .   .  .   .                  tempa[3] = getSBoxValue(tempa[3]);
    .     .     .    .    .    .    .    .    .   .   .  .   .              }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
   60    14     0    0    1    0    0    1    .   .   .  .   .              tempa[0] = tempa[0] ^ Rcon[i / Nk];
    .     .     .    .    .    .    .    .    .   .   .  .   .          }
    .     .     .    .    .    .    .    .    .   .   .  .   .  #if defined(AES256) && (AES256 == 1)
  180     0     0    1    0    0    1    0    0  90  23  .   .          if (i % Nk == 4)
    .     .     .    .    .    .    .    .    .   .   .  .   .          {
    .     .     .    .    .    .    .    .    .   .   .  .   .              // Function Subword()
    .     .     .    .    .    .    .    .    .   .   .  .   .              {
   30    16     0    1    0    0    1    .    .   .   .  .   .                  tempa[0] = getSBoxValue(tempa[0]);
   24    12     .    .    .    .    .    .    .   .   .  .   .                  tempa[1] = getSBoxValue(tempa[1]);
   24    12     0    0    1    0    0    1    .   .   .  .   .                  tempa[2] = getSBoxValue(tempa[2]);
   36    12     .    .    .    .    .    .    .   .   .  .   .                  tempa[3] = getSBoxValue(tempa[3]);
    .     .     .    .    .    .    .    .    .   .   .  .   .              }
    .     .     .    .    .    .    .    .    .   .   .  .   .          }
    .     .     .    .    .    .    .    .    .   .   .  .   .  #endif
    .     .     .    .    .    .    .    .    .   .   .  .   .          j = i * 4;
    .     .     .    .    .    .    .    .    .   .   .  .   .          k = (i - Nk) * 4;
  208   104   104    .    .    .    .    .    .   .   .  .   .          RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
  208   104   104    .    .    .    .    .    .   .   .  .   .          RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
  208   104   104    .    .    .    .    .    .   .   .  .   .          RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
  208   104   104    .    .    .    .    .    .   .   .  .   .          RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
    .     .     .    .    .    .    .    .    .   .   .  .   .      }
    4     4     .    .    .    .    .    .    .   .   .  .   .  }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  void AES_init_ctx(struct AES_ctx *ctx, const uint8_t *key)
    .     .     .    .    .    .    .    .    .   .   .  .   .  {
    .     .     .    .    .    .    .    .    .   .   .  .   .      KeyExpansion(ctx->RoundKey, key);
    .     .     .    .    .    .    .    .    .   .   .  .   .  }
    .     .     .    .    .    .    .    .    .   .   .  .   .  #if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))
    .     .     .    .    .    .    .    .    .   .   .  .   .  void AES_init_ctx_iv(struct AES_ctx *ctx, const uint8_t *key, const uint8_t *iv)
   12     0     4    1    0    0    1    .    .   .   .  .   .  {
    2     0     2    .    .    .    .    .    .   .   .  .   .      KeyExpansion(ctx->RoundKey, key);
2,054   550   422    4    5    0    4    5    0 300  39  .   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_aes.c:KeyExpansion (2x)
    .     .     .    .    .    .    .    .    .   .   .  .   .      memcpy(ctx->Iv, iv, AES_BLOCKLEN);
    8     6     .    .    .    .    .    .    .   .   .  .   .  }
    .     .     .    .    .    .    .    .    .   .   .  .   .  void AES_ctx_set_iv(struct AES_ctx *ctx, const uint8_t *iv)
    .     .     .    .    .    .    .    .    .   .   .  .   .  {
    .     .     .    .    .    .    .    .    .   .   .  .   .      memcpy(ctx->Iv, iv, AES_BLOCKLEN);
    .     .     .    .    .    .    .    .    .   .   .  .   .  }
    .     .     .    .    .    .    .    .    .   .   .  .   .  #endif
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  // This function adds the round key to state.
    .     .     .    .    .    .    .    .    .   .   .  .   .  // The round key is added to the state by an XOR function.
    .     .     .    .    .    .    .    .    .   .   .  .   .  static void AddRoundKey(uint8_t round, state_t *state, const uint8_t *RoundKey)
    .     .     .    .    .    .    .    .    .   .   .  .   .  {
    .     .     .    .    .    .    .    .    .   .   .  .   .      uint8_t i, j;
  150    96    30    1    0    0    1    .    .   .   .  .   .      for (i = 0; i < 4; ++i)
    .     .     .    .    .    .    .    .    .   .   .  .   .      {
    .     .     .    .    .    .    .    .    .   .   .  .   .          for (j = 0; j < 4; ++j)
    .     .     .    .    .    .    .    .    .   .   .  .   .          {
3,648 1,902 1,578    3    0    0    3    .    .   .   .  .   .              (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    .     .     .    .    .    .    .    .    .   .   .  .   .          }
    .     .     .    .    .    .    .    .    .   .   .  .   .      }
    .     .     .    .    .    .    .    .    .   .   .  .   .  }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  // The SubBytes Function Substitutes the values in the
    .     .     .    .    .    .    .    .    .   .   .  .   .  // state matrix with values in an S-box.
    .     .     .    .    .    .    .    .    .   .   .  .   .  static void SubBytes(state_t *state)
    .     .     .    .    .    .    .    .    .   .   .  .   .  {
    .     .     .    .    .    .    .    .    .   .   .  .   .      uint8_t i, j;
    .     .     .    .    .    .    .    .    .   .   .  .   .      for (i = 0; i < 4; ++i)
    .     .     .    .    .    .    .    .    .   .   .  .   .      {
    .     .     .    .    .    .    .    .    .   .   .  .   .          for (j = 0; j < 4; ++j)
    .     .     .    .    .    .    .    .    .   .   .  .   .          {
7,476 2,352 1,008    7    0    0    7    .    .   .   .  .   .              (*state)[j][i] = getSBoxValue((*state)[j][i]);
    .     .     .    .    .    .    .    .    .   .   .  .   .          }
    .     .     .    .    .    .    .    .    .   .   .  .   .      }
    .     .     .    .    .    .    .    .    .   .   .  .   .  }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  // The ShiftRows() function shifts the rows in the state to the left.
    .     .     .    .    .    .    .    .    .   .   .  .   .  // Each row is shifted with different offset.
    .     .     .    .    .    .    .    .    .   .   .  .   .  // Offset = Row number. So the first row is not shifted.
    .     .     .    .    .    .    .    .    .   .   .  .   .  static void ShiftRows(state_t *state)
-- line 283 ----------------------------------------
-- line 303 ----------------------------------------
    .     .     .    .    .    .    .    .    .   .   .  .   .      // Rotate third row 3 columns to left
    .     .     .    .    .    .    .    .    .   .   .  .   .      temp = (*state)[0][3];
    .     .     .    .    .    .    .    .    .   .   .  .   .      (*state)[0][3] = (*state)[3][3];
    .     .     .    .    .    .    .    .    .   .   .  .   .      (*state)[3][3] = (*state)[2][3];
    .     .     .    .    .    .    .    .    .   .   .  .   .      (*state)[2][3] = (*state)[1][3];
    .     .     .    .    .    .    .    .    .   .   .  .   .      (*state)[1][3] = temp;
    .     .     .    .    .    .    .    .    .   .   .  .   .  }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
9,750    78     0    6    0    0    6    .    .   .   .  .   .  static uint8_t xtime(uint8_t x) { return ((x << 1) ^ (((x >> 7) & 1) * 0x1b)); }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  // MixColumns function mixes the columns of the state matrix
    .     .     .    .    .    .    .    .    .   .   .  .   .  static void MixColumns(state_t *state)
    .     .     .    .    .    .    .    .    .   .   .  .   .  {
    .     .     .    .    .    .    .    .    .   .   .  .   .      uint8_t i;
    .     .     .    .    .    .    .    .    .   .   .  .   .      uint8_t Tmp, Tm, t;
    .     .     .    .    .    .    .    .    .   .   .  .   .      for (i = 0; i < 4; ++i)
    .     .     .    .    .    .    .    .    .   .   .  .   .      {
    .     .     .    .    .    .    .    .    .   .   .  .   .          t = (*state)[i][0];
1,872   312     0    2    0    0    2    .    .   .   .  .   .          Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3];
    .     .     .    .    .    .    .    .    .   .   .  .   .          Tm = (*state)[i][0] ^ (*state)[i][1];
    .     .     .    .    .    .    .    .    .   .   .  .   .          Tm = xtime(Tm);
1,872     0   624    1    0    0    1    .    .   .   .  .   .          (*state)[i][0] ^= Tm ^ Tmp;
  858    78     0    3    0    0    3    .    .   .   .  .   .          Tm = (*state)[i][1] ^ (*state)[i][2];
    .     .     .    .    .    .    .    .    .   .   .  .   .          Tm = xtime(Tm);
1,248     0   390    1    0    0    1    .    .   .   .  .   .          (*state)[i][1] ^= Tm ^ Tmp;
    .     .     .    .    .    .    .    .    .   .   .  .   .          Tm = (*state)[i][2] ^ (*state)[i][3];
    .     .     .    .    .    .    .    .    .   .   .  .   .          Tm = xtime(Tm);
1,404    78   468    .    .    .    .    .    .   .   .  .   .          (*state)[i][2] ^= Tm ^ Tmp;
  546   156     .    .    .    .    .    .    .   .   .  .   .          Tm = (*state)[i][3] ^ t;
    .     .     .    .    .    .    .    .    .   .   .  .   .          Tm = xtime(Tm);
1,248   234   390    .    .    .    .    .    .   .   .  .   .          (*state)[i][3] ^= Tm ^ Tmp;
    .     .     .    .    .    .    .    .    .   .   .  .   .      }
    .     .     .    .    .    .    .    .    .   .   .  .   .  }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  // Multiply is used to multiply numbers in the field GF(2^8)
    .     .     .    .    .    .    .    .    .   .   .  .   .  // Note: The last call to xtime() is unneeded, but often ends up generating a
    .     .     .    .    .    .    .    .    .   .   .  .   .  // smaller binary
    .     .     .    .    .    .    .    .    .   .   .  .   .  //       The compiler seems to be able to vectorize the operation better this
    .     .     .    .    .    .    .    .    .   .   .  .   .  //       way. See https://github.com/kokke/tiny-AES-c/pull/34
-- line 341 ----------------------------------------
-- line 420 ----------------------------------------
    .     .     .    .    .    .    .    .    .   .   .  .   .      (*state)[1][3] = (*state)[2][3];
    .     .     .    .    .    .    .    .    .   .   .  .   .      (*state)[2][3] = (*state)[3][3];
    .     .     .    .    .    .    .    .    .   .   .  .   .      (*state)[3][3] = temp;
    .     .     .    .    .    .    .    .    .   .   .  .   .  }
    .     .     .    .    .    .    .    .    .   .   .  .   .  #endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  // Cipher is the main function that encrypts the PlainText.
    .     .     .    .    .    .    .    .    .   .   .  .   .  static void Cipher(state_t *state, const uint8_t *RoundKey)
   66     0    42    1    0    0    1    0    0   6   .  .   .  {
    .     .     .    .    .    .    .    .    .   .   .  .   .      uint8_t round = 0;
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .      // Add the First round key to the state before starting the rounds.
    .     .     .    .    .    .    .    .    .   .   .  .   .      AddRoundKey(0, state, RoundKey);
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .      // There will be Nr rounds.
    .     .     .    .    .    .    .    .    .   .   .  .   .      // The first Nr-1 rounds are identical.
    .     .     .    .    .    .    .    .    .   .   .  .   .      // These Nr rounds are executed in the loop below.
    .     .     .    .    .    .    .    .    .   .   .  .   .      // Last one without MixColumns()
    .     .     .    .    .    .    .    .    .   .   .  .   .      for (round = 1;; ++round)
    .     .     .    .    .    .    .    .    .   .   .  .   .      {
    .     .     .    .    .    .    .    .    .   .   .  .   .          SubBytes(state);
    .     .     .    .    .    .    .    .    .   .   .  .   .          ShiftRows(state);
  186    90     0    0    0    0    0    0    0  90  34  .   .          if (round == Nr)
    .     .     .    .    .    .    .    .    .   .   .  .   .          {
    .     .     .    .    .    .    .    .    .   .   .  .   .              break;
    .     .     .    .    .    .    .    .    .   .   .  .   .          }
    .     .     .    .    .    .    .    .    .   .   .  .   .          MixColumns(state);
    .     .     .    .    .    .    .    .    .   .   .  .   .          AddRoundKey(round, state, RoundKey);
    .     .     .    .    .    .    .    .    .   .   .  .   .      }
    .     .     .    .    .    .    .    .    .   .   .  .   .      // Add round key to last round
    .     .     .    .    .    .    .    .    .   .   .  .   .      AddRoundKey(Nr, state, RoundKey);
   42    42     0    1    0    0    1    .    .   .   .  .   .  }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
    .     .     .    .    .    .    .    .    .   .   .  .   .  static void InvCipher(state_t *state, const uint8_t *RoundKey)
    .     .     .    .    .    .    .    .    .   .   .  .   .  {
    .     .     .    .    .    .    .    .    .   .   .  .   .      uint8_t round = 0;
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .      // Add the First round key to the state before starting the rounds.
    .     .     .    .    .    .    .    .    .   .   .  .   .      AddRoundKey(Nr, state, RoundKey);
-- line 459 ----------------------------------------
-- line 540 ----------------------------------------
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  #endif // #if defined(CBC) && (CBC == 1)
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  #if defined(CTR) && (CTR == 1)
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  /* Symmetrical operation: same function for encrypting as for decrypting. Note
    .     .     .    .    .    .    .    .    .   .   .  .   .   * any IV/nonce should never be reused with the same key */
    .     .     .    .    .    .    .    .    .   .   .  .   .  void AES_CTR_xcrypt_buffer(struct AES_ctx *ctx, uint8_t *buf, size_t length)
   18     2     8    1    0    0    1    .    .   .   .  .   .  {
    .     .     .    .    .    .    .    .    .   .   .  .   .      uint8_t buffer[AES_BLOCKLEN];
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .      size_t i;
    .     .     .    .    .    .    .    .    .   .   .  .   .      int bi;
  251     0     0    1    0    0    1    0    0  81   8  .   .      for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
    .     .     .    .    .    .    .    .    .   .   .  .   .      {
  304     0     0    0    0    0    0    0    0  79   6  .   .          if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    .     .     .    .    .    .    .    .    .   .   .  .   .          {
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .              memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
   18     0    12    .    .    .    .    .    .   .   .  .   .              Cipher((state_t *)buffer, ctx->RoundKey);
30,366 5,418 4,530   26    0    0   26    0    0  96  34  .   .  => /home/emilija/Desktop/password-manager-master/source/console/pm_aes.c:Cipher (6x)
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .              /* Increment Iv and handle overflow */
    8     .     .    .    .    .    .    .    .   .   .  .   .              for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
    .     .     .    .    .    .    .    .    .   .   .  .   .              {
    .     .     .    .    .    .    .    .    .   .   .  .   .                  /* inc will overflow */
   24     8     0    1    0    0    1    0    0   8   5  .   .                  if (ctx->Iv[bi] == 255)
    .     .     .    .    .    .    .    .    .   .   .  .   .                  {
    2     0     2    .    .    .    .    .    .   .   .  .   .                      ctx->Iv[bi] = 0;
    .     .     .    .    .    .    .    .    .   .   .  .   .                      continue;
    .     .     .    .    .    .    .    .    .   .   .  .   .                  }
   12     0     6    .    .    .    .    .    .   .   .  .   .                  ctx->Iv[bi] += 1;
   12     .     .    .    .    .    .    .    .   .   .  .   .                  break;
    .     .     .    .    .    .    .    .    .   .   .  .   .              }
    6     .     .    .    .    .    .    .    .   .   .  .   .              bi = 0;
    .     .     .    .    .    .    .    .    .   .   .  .   .          }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
  158    79    79    .    .    .    .    .    .   .   .  .   .          buf[i] = (buf[i] ^ buffer[bi]);
    .     .     .    .    .    .    .    .    .   .   .  .   .      }
   16    12     0    0    0    0    0    0    0   2   .  .   .  }
    .     .     .    .    .    .    .    .    .   .   .  .   .  
    .     .     .    .    .    .    .    .    .   .   .  .   .  #endif // #if defined(CTR) && (CTR == 1)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/emilija/Desktop/password-manager-master/source/console/pm_b64.c
--------------------------------------------------------------------------------
Ir    Dr    Dw I1mr D1mr D1mw ILmr DLmr DLmw Bc    Bcm Bi Bim 

-- line 4 ----------------------------------------
    .     .  .    .    .    .    .    .    .     .   .  .   .  #include "console/b64.h"
    .     .  .    .    .    .    .    .    .     .   .  .   .  #include "console/util.h"
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    .     .  .    .    .    .    .    .    .     .   .  .   .  #include <ctype.h>
    .     .  .    .    .    .    .    .    .     .   .  .   .  #include <stdlib.h>
    .     .  .    .    .    .    .    .    .     .   .  .   .  #include <string.h>
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    .     .  .    .    .    .    .    .    .     .   .  .   .  uint8_t *b64_decode(const uint8_t *src, size_t len, size_t *out_len)
   14     1  8    1    0    0    1    .    .     .   .  .   .  {
    1     .  .    .    .    .    .    .    .     .   .  .   .      int i = 0;
    .     .  .    .    .    .    .    .    .     .   .  .   .      int j = 0;
    .     .  .    .    .    .    .    .    .     .   .  .   .      int l = 0;
    3     .  .    .    .    .    .    .    .     .   .  .   .      size_t ln = 0;
    .     .  .    .    .    .    .    .    .     .   .  .   .      uint8_t *dec = 0;
    .     .  .    .    .    .    .    .    .     .   .  .   .      uint8_t buf[3];
    .     .  .    .    .    .    .    .    .     .   .  .   .      uint8_t tmp[4];
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    5     0  1    1    0    0    1    .    .     .   .  .   .      dec = (uint8_t *)calloc(1, len * 3 / 4 + 1);
  224    41 32    7    0    0    7    0    0    37  16  1   1  => ???:0x000000000010a3f0 (1x)
    3     0  0    0    0    0    0    0    0     1   .  .   .      ASSERT_ALLOC(dec);
    .     .  .    .    .    .    .    .    .     .   .  .   .  
  172     8 10    3    0    0    3    0    0    53   2  .   .      while (len--)
    .     .  .    .    .    .    .    .    .     .   .  .   .      {
  156    52  0    0    0    0    0    0    0    52   1  .   .          if ('=' == src[j])
    .     .  .    .    .    .    .    .    .     .   .  .   .          {
    .     .  .    .    .    .    .    .    .     .   .  .   .              break;
    .     .  .    .    .    .    .    .    .     .   .  .   .          }
  306   102 51    1    3    0    1    1    0    51   6  .   .          if (!(isalnum(src[j]) || '+' == src[j] || '/' == src[j]))
  306   204  0    1    1    0    1    0    0     0   0 51   1  => ???:0x000000000010a590 (51x)
    .     .  .    .    .    .    .    .    .     .   .  .   .          {
    .     .  .    .    .    .    .    .    .     .   .  .   .              break;
    .     .  .    .    .    .    .    .    .     .   .  .   .          }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
  153     0 51    .    .    .    .    .    .     .   .  .   .          tmp[i++] = src[j++];
    .     .  .    .    .    .    .    .    .     .   .  .   .  
  126    24  0    0    0    0    0    0    0    51  31  .   .          if (4 == i)
    .     .  .    .    .    .    .    .    .     .   .  .   .          {
  144     0  0    0    0    0    0    0    0    48  15  .   .              for (i = 0; i < 4; ++i)
    .     .  .    .    .    .    .    .    .     .   .  .   .              {
4,710     0  0    0    0    0    0    0    0 1,570   .  .   .                  for (l = 0; l < 64; ++l)
    .     .  .    .    .    .    .    .    .     .   .  .   .                  {
4,998 1,666  0    1    1    0    1    1    0 1,618  64  .   .                      if (tmp[i] == b64_table[l])
    .     .  .    .    .    .    .    .    .     .   .  .   .                      {
   48     0 48    .    .    .    .    .    .     .   .  .   .                          tmp[i] = l;
    .     .  .    .    .    .    .    .    .     .   .  .   .                          break;
    .     .  .    .    .    .    .    .    .     .   .  .   .                      }
    .     .  .    .    .    .    .    .    .     .   .  .   .                  }
    .     .  .    .    .    .    .    .    .     .   .  .   .              }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
   84    24 12    1    0    0    1    .    .     .   .  .   .              buf[0] = (tmp[0] << 2) + ((tmp[1] & 0x30) >> 4);
  108    12 24    .    .    .    .    .    .     .   .  .   .              buf[1] = ((tmp[1] & 0xf) << 4) + ((tmp[2] & 0x3c) >> 2);
   48    12 12    .    .    .    .    .    .     .   .  .   .              buf[2] = ((tmp[2] & 0x3) << 6) + tmp[3];
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    .     .  .    .    .    .    .    .    .     .   .  .   .              for (i = 0; i < 3; ++i)
    .     .  .    .    .    .    .    .    .     .   .  .   .              {
   72    12 36    .    .    .    .    .    .     .   .  .   .                  dec[ln++] = buf[i];
    .     .  .    .    .    .    .    .    .     .   .  .   .              }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
   12     .  .    .    .    .    .    .    .     .   .  .   .              i = 0;
    .     .  .    .    .    .    .    .    .     .   .  .   .          }
    .     .  .    .    .    .    .    .    .     .   .  .   .      }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    2     0  0    0    0    0    0    0    0     1   .  .   .      if (i > 0)
    .     .  .    .    .    .    .    .    .     .   .  .   .      {
    2     0  0    1    0    0    1    0    0     1   .  .   .          for (j = i; j < 4; ++j)
    .     .  .    .    .    .    .    .    .     .   .  .   .          {
   17     0  1    0    0    0    0    0    0     2   .  .   .              tmp[j] = '\0';
    .     .  .    .    .    .    .    .    .     .   .  .   .          }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
   12     0  0    0    0    0    0    0    0     4   2  .   .          for (j = 0; j < 4; ++j)
    .     .  .    .    .    .    .    .    .     .   .  .   .          {
  540     0  0    0    0    0    0    0    0   180   1  .   .              for (l = 0; l < 64; ++l)
    .     .  .    .    .    .    .    .    .     .   .  .   .              {
  561   187  0    1    0    0    1    0    0   183  12  .   .                  if (tmp[j] == b64_table[l])
    .     .  .    .    .    .    .    .    .     .   .  .   .                  {
    3     0  3    .    .    .    .    .    .     .   .  .   .                      tmp[j] = l;
    .     .  .    .    .    .    .    .    .     .   .  .   .                      break;
    .     .  .    .    .    .    .    .    .     .   .  .   .                  }
    .     .  .    .    .    .    .    .    .     .   .  .   .              }
    .     .  .    .    .    .    .    .    .     .   .  .   .          }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    8     2  1    1    0    0    1    .    .     .   .  .   .          buf[0] = (tmp[0] << 2) + ((tmp[1] & 0x30) >> 4);
    7     1  1    .    .    .    .    .    .     .   .  .   .          buf[1] = ((tmp[1] & 0xf) << 4) + ((tmp[2] & 0x3c) >> 2);
    3     1  1    .    .    .    .    .    .     .   .  .   .          buf[2] = ((tmp[2] & 0x3) << 6) + tmp[3];
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    2     0  0    0    0    0    0    0    0     1   .  .   .          for (j = 0; (j < i - 1); ++j)
    .     .  .    .    .    .    .    .    .     .   .  .   .          {
    7     0  1    1    0    0    1    .    .     .   .  .   .              dec[ln++] = buf[j];
   19     4  2    4    0    0    4    0    0     5   1  1   1  => ???:0x000000000010a410 (1x)
    .     .  .    .    .    .    .    .    .     .   .  .   .          }
    .     .  .    .    .    .    .    .    .     .   .  .   .      }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    1     0  1    .    .    .    .    .    .     .   .  .   .      dec[ln] = '\0';
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    3     1  0    0    0    0    0    0    0     1   .  .   .      if (out_len != 0)
    1     0  1    .    .    .    .    .    .     .   .  .   .          *out_len = ln;
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    .     .  .    .    .    .    .    .    .     .   .  .   .      return dec;
   12     9  0    0    0    0    0    0    0     1   .  .   .  }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    .     .  .    .    .    .    .    .    .     .   .  .   .  char *b64_encode(const uint8_t *src, size_t len, size_t *out_len)
   11     1  4    2    0    0    2    .    .     .   .  .   .  {
    .     .  .    .    .    .    .    .    .     .   .  .   .      int i = 0;
    .     .  .    .    .    .    .    .    .     .   .  .   .      int j = 0;
    .     .  .    .    .    .    .    .    .     .   .  .   .      char *enc = 0;
    1     .  .    .    .    .    .    .    .     .   .  .   .      size_t ln = 0;
    .     .  .    .    .    .    .    .    .     .   .  .   .      uint8_t buf[4];
    .     .  .    .    .    .    .    .    .     .   .  .   .      uint8_t tmp[3];
    .     .  .    .    .    .    .    .    .     .   .  .   .  
   10     0  1    .    .    .    .    .    .     .   .  .   .      enc = (char *)calloc(1, (((4 * len / 3) + 3) & ~3) + 1);
  229    41 34    0    0    2    0    0    2    38   0  1   .  => ???:0x000000000010a3f0 (1x)
    2     0  0    0    0    0    0    0    0     1   .  .   .      ASSERT_ALLOC(enc);
    .     .  .    .    .    .    .    .    .     .   .  .   .  
  128     0  0    0    0    0    0    0    0    42   3  .   .      while (len--)
    .     .  .    .    .    .    .    .    .     .   .  .   .      {
  284    41 41    2    0    0    2    0    0     1   .  .   .          tmp[i++] = *(src++);
    .     .  .    .    .    .    .    .    .     .   .  .   .  
   80     0  0    0    0    0    0    0    0    40   5  .   .          if (3 == i)
    .     .  .    .    .    .    .    .    .     .   .  .   .          {
   39    13  0    2    0    0    2    .    .     .   .  .   .              buf[0] = (tmp[0] & 0xfc) >> 2;
   78    13  .    .    .    .    .    .    .     .   .  .   .              buf[1] = ((tmp[0] & 0x03) << 4) + ((tmp[1] & 0xf0) >> 4);
   78    13  .    .    .    .    .    .    .     .   .  .   .              buf[2] = ((tmp[1] & 0x0f) << 2) + ((tmp[2] & 0xc0) >> 6);
    .     .  .    .    .    .    .    .    .     .   .  .   .              buf[3] = tmp[2] & 0x3f;
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    .     .  .    .    .    .    .    .    .     .   .  .   .              for (i = 0; i < 4; ++i)
    .     .  .    .    .    .    .    .    .     .   .  .   .              {
  197    52 52    1    0    0    1    .    .     .   .  .   .                  enc[ln++] = b64_table[buf[i]];
    .     .  .    .    .    .    .    .    .     .   .  .   .              }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
   13     .  .    .    .    .    .    .    .     .   .  .   .              i = 0;
    .     .  .    .    .    .    .    .    .     .   .  .   .          }
    .     .  .    .    .    .    .    .    .     .   .  .   .      }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    2     0  0    0    0    0    0    0    0     1   .  .   .      if (i > 0)
    .     .  .    .    .    .    .    .    .     .   .  .   .      {
    .     .  .    .    .    .    .    .    .     .   .  .   .          for (j = i; j < 3; ++j)
    .     .  .    .    .    .    .    .    .     .   .  .   .          {
   14     0  1    1    0    0    1    0    0     2   .  .   .              tmp[j] = '\0';
    .     .  .    .    .    .    .    .    .     .   .  .   .          }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    3     1  .    .    .    .    .    .    .     .   .  .   .          buf[0] = (tmp[0] & 0xfc) >> 2;
    5     1  .    .    .    .    .    .    .     .   .  .   .          buf[1] = ((tmp[0] & 0x03) << 4) + ((tmp[1] & 0xf0) >> 4);
    5     1  0    1    0    0    1    .    .     .   .  .   .          buf[2] = ((tmp[1] & 0x0f) << 2) + ((tmp[2] & 0xc0) >> 6);
    .     .  .    .    .    .    .    .    .     .   .  .   .          buf[3] = tmp[2] & 0x3f;
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    2     0  0    0    0    0    0    0    0     1   .  .   .          for (j = 0; (j < i + 1); ++j)
    .     .  .    .    .    .    .    .    .     .   .  .   .          {
   13     3  3    1    0    0    1    .    .     .   .  .   .              enc[ln++] = b64_table[buf[j]];
    .     .  .    .    .    .    .    .    .     .   .  .   .          }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    .     .  .    .    .    .    .    .    .     .   .  .   .          while ((i++ < 3))
    .     .  .    .    .    .    .    .    .     .   .  .   .          {
   15     0  1    0    0    0    0    0    0     2   .  .   .              enc[ln++] = '=';
    .     .  .    .    .    .    .    .    .     .   .  .   .          }
    .     .  .    .    .    .    .    .    .     .   .  .   .      }
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    1     0  1    .    .    .    .    .    .     .   .  .   .      enc[ln] = '\0';
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    2     0  0    0    0    0    0    0    0     1   .  .   .      if (out_len != 0)
    1     0  1    .    .    .    .    .    .     .   .  .   .          *out_len = ln;
    .     .  .    .    .    .    .    .    .     .   .  .   .  
    .     .  .    .    .    .    .    .    .     .   .  .   .      return enc;
    8     6  0    0    0    0    0    0    0     1   .  .   .  }

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c
  /build/glibc-LcI20x/glibc-2.31/ctype/../include/ctype.h
  /build/glibc-LcI20x/glibc-2.31/elf/../elf/dl-runtime.c
  /build/glibc-LcI20x/glibc-2.31/elf/../elf/dl-sysdep.c
  /build/glibc-LcI20x/glibc-2.31/elf/../elf/dl-tls.c
  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/generic/ldsodefs.h
  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/unix/sysv/linux/dl-sysdep.c
  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/x86/cpu-features.c
  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/x86/dl-prop.h
  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/x86_64/dl-machine.h
  /build/glibc-LcI20x/glibc-2.31/elf/../sysdeps/x86_64/dl-trampoline.h
  /build/glibc-LcI20x/glibc-2.31/elf/./dl-load.h
  /build/glibc-LcI20x/glibc-2.31/elf/./dl-map-segments.h
  /build/glibc-LcI20x/glibc-2.31/elf/dl-addr.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-cache.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-deps.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-environ.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-error-skeleton.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-fini.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-hwcaps.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-init.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-load.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-lookup.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-minimal.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-misc.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-object.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-reloc.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-sort-maps.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-tunables.c
  /build/glibc-LcI20x/glibc-2.31/elf/dl-tunables.h
  /build/glibc-LcI20x/glibc-2.31/elf/dl-version.c
  /build/glibc-LcI20x/glibc-2.31/elf/do-rel.h
  /build/glibc-LcI20x/glibc-2.31/elf/get-dynamic-info.h
  /build/glibc-LcI20x/glibc-2.31/elf/rtld.c
  /build/glibc-LcI20x/glibc-2.31/io/../sysdeps/unix/sysv/linux/open64_nocancel.c
  /build/glibc-LcI20x/glibc-2.31/io/../sysdeps/unix/sysv/linux/wordsize-64/fxstat.c
  /build/glibc-LcI20x/glibc-2.31/io/../sysdeps/unix/sysv/linux/wordsize-64/xstat.c
  /build/glibc-LcI20x/glibc-2.31/libio/fileops.c
  /build/glibc-LcI20x/glibc-2.31/libio/genops.c
  /build/glibc-LcI20x/glibc-2.31/libio/libioP.h
  /build/glibc-LcI20x/glibc-2.31/malloc/arena.c
  /build/glibc-LcI20x/glibc-2.31/malloc/malloc.c
  /build/glibc-LcI20x/glibc-2.31/misc/../sysdeps/unix/sysv/linux/mmap64.c
  /build/glibc-LcI20x/glibc-2.31/nptl/../nptl/pthread_mutex_lock.c
  /build/glibc-LcI20x/glibc-2.31/nptl/../sysdeps/unix/sysv/linux/open64.c
  /build/glibc-LcI20x/glibc-2.31/nptl/../sysdeps/unix/sysv/linux/sigaction.c
  /build/glibc-LcI20x/glibc-2.31/nptl/libc_pthread_init.c
  /build/glibc-LcI20x/glibc-2.31/nptl/nptl-init.c
  /build/glibc-LcI20x/glibc-2.31/nptl/pthread_mutex_unlock.c
  /build/glibc-LcI20x/glibc-2.31/nptl/register-atfork.c
  /build/glibc-LcI20x/glibc-2.31/setjmp/../sysdeps/x86_64/setjmp.S
  /build/glibc-LcI20x/glibc-2.31/stdlib/../stdlib/strtol_l.c
  /build/glibc-LcI20x/glibc-2.31/stdlib/../sysdeps/unix/sysv/linux/x86/lowlevellock.h
  /build/glibc-LcI20x/glibc-2.31/stdlib/cxa_finalize.c
  /build/glibc-LcI20x/glibc-2.31/stdlib/exit.c
  /build/glibc-LcI20x/glibc-2.31/stdlib/getenv.c
  /build/glibc-LcI20x/glibc-2.31/stdlib/rand.c
  /build/glibc-LcI20x/glibc-2.31/stdlib/random.c
  /build/glibc-LcI20x/glibc-2.31/stdlib/random_r.c
  /build/glibc-LcI20x/glibc-2.31/string/../bits/stdlib-bsearch.h
  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86/cacheinfo.c
  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/multiarch/../strchr.S
  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/multiarch/../strlen.S
  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/strcmp.S
  /build/glibc-LcI20x/glibc-2.31/string/../sysdeps/x86_64/strcspn.S
  /build/glibc-LcI20x/glibc-2.31/string/strdup.c

--------------------------------------------------------------------------------
Ir     Dr    Dw    I1mr D1mr D1mw ILmr DLmr DLmw Bc    Bcm Bi Bim 
--------------------------------------------------------------------------------
48,671 8,967 5,627  118   20    2  118   13    1 4,990 363  .   .  events annotated

